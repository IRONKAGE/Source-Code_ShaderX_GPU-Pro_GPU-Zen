
fileName2Source_["shaders/bent_normal_ray_marching.frag"] = 
"#version 330 core \n"
" \n"
"#define final \n"
" \n"
"uniform sampler2D positionTexture; \n"
"uniform sampler2D normalTexture; \n"
" \n"
"uniform mat4 viewMatrix; \n"
"uniform mat4 viewProjectionMatrix; \n"
" \n"
"uniform float sampleRadius; \n"
"uniform float maxDistance; \n"
" \n"
"uniform int sampleCount; \n"
"uniform int numRayMarchingSteps; \n"
"uniform int patternSize; \n"
" \n"
"uniform sampler2D seedTexture; \n"
" \n"
"in vec2 texcoord; \n"
" \n"
"layout(location = 0) out vec4 outBNAO; \n"
" \n"
"vec3 encodeNormal(const in vec3 normal) { \n"
"	return normal * 0.5 + 0.5; \n"
"} \n"
" \n"
"void checkSSVisibilitySmooth( \n"
"	const in vec3 csPosition, const in sampler2D positionTexture, \n"
"	const in mat4 viewMatrix, const in mat4 viewProjectionMatrix, \n"
"	const in vec3 wsSample, const in float outlierDistance, \n"
"	inout float visibility, inout bool nonOutlier) \n"
"{ \n"
"	// transform world space sample to camera space \n"
"	vec3 csSample = (viewMatrix * vec4(wsSample, 1.0)).xyz; \n"
" \n"
"	// project to ndc and then to texture space to sample depth/position buffer to check for occlusion \n"
"	vec4 ndcSamplePosition = viewProjectionMatrix * vec4(wsSample, 1.0); \n"
"	//if(ndcSamplePosition.w == 0.0) continue; \n"
"	ndcSamplePosition.xy /= ndcSamplePosition.w; \n"
"	vec2 tsSamplePosition = ndcSamplePosition.xy * 0.5 + 0.5; \n"
" \n"
"	// optimization: replace position buffer with depth buffer \n"
"	// here we get a world space position \n"
"	// we found the background... \n"
"	vec4 wsReferenceSamplePosition = texture(positionTexture, tsSamplePosition); \n"
"	if(wsReferenceSamplePosition.w == 0.0) { \n"
"		nonOutlier = true; \n"
"		//visibility *= 1.0; \n"
"		return; \n"
"	} \n"
"	// transform to camera space \n"
"	vec3 csReferenceSamplePosition = (viewMatrix * vec4(wsReferenceSamplePosition.xyz, 1.0)).xyz; \n"
" \n"
"	////////////////////////////////////////////////////////////////////////// \n"
"	// optional: apply some code to handle background \n"
"	////////////////////////////////////////////////////////////////////////// \n"
" \n"
"	// check for occlusion (within camera space, simple test along z axis; remember z axis goes along -z in OpenGL!) \n"
"	// optimized code checks depth values \n"
"	// could apply small depth bias here to avoid precision errors \n"
"	if(-csReferenceSamplePosition.z < -csSample.z) { \n"
"		// we have a occlusion \n"
"		// check, if the occlusion is within a application-defined range \n"
"		if(abs(csPosition.z - csReferenceSamplePosition.z) < outlierDistance) { \n"
"			// valid occlusion \n"
"			//visibility = 0.0; \n"
"			//visibility *= sqrt(abs(csPosition.z - csReferenceSamplePosition.z) / outlierDistance); \n"
"			visibility *= pow(abs(csPosition.z - csReferenceSamplePosition.z) / outlierDistance, 2.0); \n"
"			nonOutlier = true; \n"
"		} \n"
"		else { \n"
"			// occluder is too far away, we don't know, what that means for our test \n"
"			// test for this sample is \"undefined\" \n"
"		} \n"
"	} \n"
"	else { \n"
"		// we have no occlusion, thus: \n"
"		// -csReferenceSamplePosition.z == -csSample.z \n"
"		nonOutlier = true; \n"
"	} \n"
"} \n"
" \n"
"void checkSSVisibilityWithRayMarchingSmooth( \n"
"	const in vec3 csPosition, const in sampler2D positionTexture, \n"
"	const in mat4 viewMatrix, const in mat4 viewProjectionMatrix, \n"
"	const in vec3 wsPosition, const in float outlierDistance, \n"
"	const in vec3 ray, const in float sampleRadius, \n"
"	const in int rayMarchingSteps, const in float rayMarchingStartOffset, \n"
"	inout float visibility, inout bool nonOutlier) \n"
"{ \n"
"	for(int k=0; k<rayMarchingSteps; k++) { \n"
"		// world space sample radius within we check for occluders (larger radius needs more ray marching steps) \n"
"		vec3 wsSample = wsPosition + ray * (sampleRadius * (float(k) / float(rayMarchingSteps) + rayMarchingStartOffset)); \n"
"		checkSSVisibilitySmooth( \n"
"			csPosition, positionTexture, \n"
"			viewMatrix, viewProjectionMatrix, \n"
"			wsSample, outlierDistance,  \n"
"			visibility, nonOutlier); \n"
"	} \n"
"} \n"
" \n"
"// normal is parallel to n \n"
"void createOrthoNormalBasis(const in vec3 n, out vec3 tangent, out vec3 binormal, out vec3 normal) { \n"
"	normal = normalize(n); \n"
" \n"
"	if(abs(normal.x) > abs(normal.z)) { \n"
"		binormal = vec3(-normal.y, normal.x, 0.0); \n"
"	} \n"
"	else { \n"
"		binormal = vec3(0.0, -normal.z, normal.y); \n"
"	} \n"
" \n"
"	binormal = normalize(binormal); \n"
"	tangent = cross(binormal, normal); \n"
"} \n"
" \n"
"void createOrthoNormalBasisUnsafe(const in vec3 n, out vec3 tangent, out vec3 binormal, out vec3 normal) { \n"
"	normal = normalize(n); \n"
" \n"
"	binormal = vec3(-normal.y, normal.x, 0.0); \n"
"	binormal = normalize(binormal); \n"
"	tangent = cross(binormal, normal); \n"
"} \n"
" \n"
"void main() { \n"
"	outBNAO = vec4(0.0); \n"
" \n"
"	////////////////////////////////////////////////////////////////////////// \n"
"	// ws = world space \n"
"	// cs = camera space \n"
"	// ndc = normal device coordinates \n"
"	// ts = texture space \n"
"	////////////////////////////////////////////////////////////////////////// \n"
"	final vec4 wsPosition = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0); \n"
"	// background \n"
"	if(wsPosition.w == 0) return; \n"
"	final vec3 csPosition = (viewMatrix * vec4(wsPosition.xyz, 1.0)).xyz; \n"
"	final vec3 wsNormal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb; \n"
" \n"
"	int validTests = 0; \n"
"	float ao = 0.0; \n"
"	vec3 bentNormal = vec3(0.0); \n"
"	float visibilityRays = 0.0; \n"
" \n"
"	// get a different set of samples, depending on pixel position in pattern \n"
"	int patternIndex =  \n"
"		(int(gl_FragCoord.x) & (patternSize - 1)) +  \n"
"		(int(gl_FragCoord.y) & (patternSize - 1)) * patternSize; \n"
" \n"
"	//vec3 u,v,w; \n"
"	//createOrthoNormalBasisUnsafe(wsNormal, u, v, w); \n"
"	//createOrthoNormalBasis(wsNormal, u, v, w); \n"
" \n"
"	for(int i=0; i<sampleCount; i++) { \n"
"		////////////////////////////////////////////////////////////////////////// \n"
"		// seed texture holds samples \n"
"		// y selects pattern \n"
"		// x coordinate gives samples from set \n"
"		vec4 data = texelFetch(seedTexture, ivec2(i, patternIndex), 0); \n"
"		float rayMarchingStartOffset = data.a; \n"
"		vec3 ray = data.rgb; \n"
"		//final vec3 ray = data.x*u + data.y*v + data.z*w; \n"
"		// bring it to the local hemisphere \n"
"		// we do not need a ONB, because we have a uniform distribution \n"
"		// simple inversion is ok \n"
"		if(dot(ray, wsNormal) < 0.0) { \n"
"			ray *= -1.0; \n"
"		} \n"
" \n"
"		//////////////////////////////////////////////////////////////////////////// \n"
"		//// perform ray marching along the direction \n"
"		//bool occluded = false; \n"
"		//// if the occluder is too far away, we cannot count the sample \n"
"		//// screen-space limitation, which could be reduced by depth peeling or scene voxelization \n"
"		//bool nonOutlier = false; \n"
"		// \n"
"		//checkSSVisibilityWithRayMarching( \n"
"		//	csPosition, positionTexture, \n"
"		//	viewMatrix, viewProjectionMatrix, \n"
"		//	wsPosition.xyz, maxDistance, \n"
"		//	ray, sampleRadius, rayMarchingSteps, rayMarchingStartOffset, \n"
"		//	occluded, nonOutlier); \n"
"		//////////////////////////////////////////////////////////////////////////// \n"
" \n"
"		////////////////////////////////////////////////////////////////////////// \n"
"		// perform ray marching along the direction \n"
"		float visibility = 1.0; \n"
"		// if the occluder is too far away, we cannot count the sample \n"
"		// screen-space limitation, which could be reduced by depth peeling or scene voxelization \n"
"		bool nonOutlier = false; \n"
" \n"
"		checkSSVisibilityWithRayMarchingSmooth( \n"
"			csPosition, positionTexture, \n"
"			viewMatrix, viewProjectionMatrix, \n"
"			wsPosition.xyz, maxDistance, \n"
"			ray, sampleRadius, numRayMarchingSteps, rayMarchingStartOffset, \n"
"			visibility, nonOutlier); \n"
"		////////////////////////////////////////////////////////////////////////// \n"
" \n"
" \n"
"		// evaluate the ray marching steps \n"
"		// visibility encodes how much this direction is occluded \n"
"		// one could also do that binary, but that may cause artifacts, when visibilty is checked in SS \n"
" \n"
"		// note: we assume no occlusion if the occluder is too far away \n"
"		// for bent normals we cannot simply \"skip\" these directions \n"
"		bentNormal += ray * visibility; \n"
"		visibilityRays += visibility; \n"
" \n"
"		if(nonOutlier) { \n"
"			validTests++; \n"
"			// extension: weight ao by angle and/or distance to occluder \n"
"			ao += visibility; \n"
"		} \n"
"	} \n"
" \n"
"	if(validTests == 0) { \n"
"		outBNAO.a = 0.0; \n"
"	} \n"
"	else { \n"
"		outBNAO.a = ao / float(validTests); \n"
"	} \n"
"	if(dot(bentNormal, vec3(1.0)) != 0.0) { \n"
"		bentNormal /= float(visibilityRays); \n"
"		outBNAO.xyz = encodeNormal(bentNormal-wsNormal); \n"
"	} \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/quad.vert"] = 
"#version 330 core   \n"
" \n"
"layout(location = 0) in vec2 position; \n"
" \n"
"void main() { \n"
"	gl_Position = vec4(position, 0.0, 1.0); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/bent_normal_blurring.frag"] = 
"#version 330 core \n"
" \n"
"#define final \n"
" \n"
"uniform sampler2D positionTexture; \n"
"uniform sampler2D normalTexture; \n"
" \n"
"uniform float positionPower; \n"
"uniform float normalPower; \n"
" \n"
"uniform int kernelSize; \n"
"uniform ivec2 maskDirection; \n"
"uniform int subSampling; \n"
" \n"
"uniform sampler2D inputTexture; \n"
" \n"
"//#ifndef SPATIAL_WEIGHTS_SET \n"
"//const float spatialWeights[] = float[2](1.0, 1.0); \n"
"//#endif \n"
" \n"
"out vec4 outLayer; \n"
" \n"
"vec3 encodeNormal(const in vec3 normal) { \n"
"	return normal * 0.5 + 0.5; \n"
"} \n"
" \n"
"vec3 decodeNormal(const in vec3 normal) { \n"
"	return normal * 2.0 - 1.0; \n"
"} \n"
" \n"
"void main() { \n"
"	final ivec2 texCoord = ivec2(gl_FragCoord.xy); \n"
"	 \n"
"	final vec4 position = texelFetch(positionTexture, texCoord, 0); \n"
"	if(position.w == 0.0) { \n"
"		outLayer = vec4(0.0); \n"
"		return; \n"
"	} \n"
"	final vec3 normal = texelFetch(normalTexture, texCoord, 0).rgb; \n"
"	 \n"
"	vec3 bentNormal = vec3(0.0); \n"
"	float ao = 0.0; \n"
"	float weightSum = 0.0; \n"
" \n"
"	for(int i=0; i<kernelSize; i+=max(1, subSampling)) { \n"
"		final ivec2 sampleTexCoord = texCoord + (i - kernelSize/2) * maskDirection; \n"
" \n"
"		final vec3 sampleNormal = texelFetch(normalTexture, sampleTexCoord, 0).rgb; \n"
"		final vec4 samplePosition = texelFetch(positionTexture, sampleTexCoord, 0); \n"
"		if(samplePosition.w == 0.0) continue; \n"
"		// The alpha of the position texture should be used ! \n"
"		// If it is zero, we are undefined! \n"
" \n"
"		final float normalWeight = pow(dot(sampleNormal, normal) * 0.5 + 0.5, normalPower); \n"
" \n"
"		final float positionWeight = 1.0 / pow(1.0 + distance(position.xyz, samplePosition.xyz), positionPower); \n"
" \n"
"		//// we use a simple box filter to exactly blur the pattern (spatialWeights[?] == 1.0) \n"
"		//final float weight = normalWeight * positionWeight * spatialWeights[i]; \n"
"		final float weight = normalWeight * positionWeight; \n"
" \n"
"		final vec4 sampleData = texelFetch(inputTexture, sampleTexCoord, 0); \n"
" \n"
"		final float aoSample = sampleData.a; \n"
"		ao += weight * aoSample; \n"
"		 \n"
"		final vec3 bentNormalSample = decodeNormal(sampleData.rgb); \n"
"		bentNormal += weight * bentNormalSample; \n"
" \n"
"		weightSum += weight; \n"
" 	} \n"
" \n"
"	outLayer.rgb = encodeNormal(bentNormal / weightSum); \n"
"	outLayer.a = ao / weightSum; \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/quad_texcoord.vert"] = 
"#version 330 core   \n"
" \n"
"layout(location = 0) in vec2 position; \n"
" \n"
"out vec2 texcoord; \n"
" \n"
"void main() { \n"
"    texcoord = step(0.0, position); \n"
"    gl_Position = vec4(position, 0.0, 1.0); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/env_map_convolution.frag"] = 
"#version 330 core \n"
" \n"
"#define final \n"
"#define M_PI	3.14159265358979323846  \n"
"#define M_1_PI	0.318309886183790671538 \n"
" \n"
"uniform samplerCube inputCube; \n"
" \n"
"uniform int sampleCount; \n"
"uniform float cutOffAngle; \n"
" \n"
"in vec2 texcoord; \n"
" \n"
"layout(location = 0) out vec3 posXLayer; \n"
"layout(location = 1) out vec3 negXLayer; \n"
"layout(location = 2) out vec3 posYLayer; \n"
"layout(location = 3) out vec3 negYLayer; \n"
"layout(location = 4) out vec3 posZLayer; \n"
"layout(location = 5) out vec3 negZLayer; \n"
" \n"
"float computeGeometricTerm(const in vec3 inDirection, const in vec3 outDirection) { \n"
"	return max(0.0, dot(inDirection, outDirection)); \n"
"} \n"
" \n"
"float computeReflectance(const in vec3 inDirection, const in vec3 outDirection) { \n"
"	return M_1_PI; // lambert \n"
"} \n"
" \n"
"vec3 computeIncomingRadiance(const in vec3 inDirection) { \n"
"	return texture(inputCube, inDirection).rgb; \n"
"} \n"
" \n"
"float computePDF(const in vec3 inDirection) { \n"
"	return M_1_PI * 0.5; // uniform \n"
"} \n"
" \n"
"vec3 computeRadiance(const in vec3 inDirection, const in vec3 outDirection) {	 \n"
"	return  \n"
"		computeIncomingRadiance(inDirection) * 		  \n"
"		computeReflectance(inDirection, outDirection) *  \n"
"		computeGeometricTerm(inDirection, outDirection) / \n"
"		computePDF(inDirection); \n"
"} \n"
" \n"
"float computeConeWeight(const in vec3 inDirection, const in vec3 outDirection, const in float cutOffAngleCosine) { \n"
"	float angle = dot(inDirection, outDirection); \n"
"	if(angle > cutOffAngleCosine) return 1.0; \n"
"	return 0.0; \n"
"} \n"
" \n"
"vec3 unitSphericalToCarthesian(const vec2 spherical) { \n"
"	final float phi = spherical.x; \n"
"	final float theta = spherical.y; \n"
"	final float x = sin(phi) * sin(theta); \n"
"	final float y = cos(phi) * sin(theta); \n"
"	final float z = cos(theta); \n"
"	return vec3(x, y, z); \n"
"} \n"
" \n"
"void createOrthoNormalBasis(const in vec3 n, out vec3 tangent, out vec3 binormal, out vec3 normal) { \n"
"	normal = normalize(n); \n"
" \n"
"	if(abs(normal.x) > abs(normal.z)) { \n"
"		binormal = vec3(-normal.y, normal.x, 0.0); \n"
"	} \n"
"	else { \n"
"		binormal = vec3(0.0, -normal.z, normal.y); \n"
"	} \n"
" \n"
"	binormal = normalize(binormal); \n"
"	tangent = cross(binormal, normal); \n"
"} \n"
" \n"
"vec3 computeConvolutionForDirection(const in vec3 direction) { \n"
"	vec3 radianceSum = vec3(0.0); \n"
" \n"
"	vec3 u,v,w; \n"
"	createOrthoNormalBasis(direction, u,v,w); \n"
" \n"
"	final float cutOffAngleCosine = cos(cutOffAngle); \n"
" \n"
"	ivec2 sampleCount = ivec2(sampleCount, sampleCount); \n"
"	float weigthsSum = 0.0; \n"
" \n"
"	for(int i = 0; i < sampleCount.y; i++) { \n"
"		for(int j = 0; j < sampleCount.x; j++) { \n"
"			final float s = 2.0 * M_PI * (float(j)+0.5) / float(sampleCount.x); \n"
"			// uniform sampling of hemisphere \n"
"			//final float t = acos((float(i)+0.5) / float(sampleCount.y)); \n"
"			final float t = acos((float(i)+0.5) / float(sampleCount.y) * ((1.0 - cutOffAngleCosine) + cutOffAngleCosine)); \n"
"			final vec3 sampleDirection = unitSphericalToCarthesian(vec2(s, t)); \n"
" \n"
"			// transform to orthonormal basis of direction \n"
"			final vec3 finalSampleDirection = sampleDirection.x * u + sampleDirection.y * v + sampleDirection.z * w; \n"
" \n"
"			final vec3 radianceSample = computeRadiance(finalSampleDirection, direction); \n"
"			final float coneWeight = 1.0; // all samples in cone \n"
"			weigthsSum += coneWeight; \n"
"			radianceSum += coneWeight * radianceSample; \n"
"		} \n"
"	} \n"
"	radianceSum.rgb /= weigthsSum; \n"
" \n"
"	return radianceSum.rgb; \n"
"} \n"
" \n"
"void main() { \n"
"	final float s = 2.0 * texcoord.x - 1.0; \n"
"	final float t = 2.0 * texcoord.y - 1.0; \n"
"	 \n"
"/* \n"
"	major axis \n"
"	direction     target                             sc     tc    ma \n"
"	----------    -------------------------------    ---    ---   --- \n"
"	+rx          TEXTURE_CUBE_MAP_POSITIVE_X_ARB    -rz    -ry   rx \n"
"	-rx          TEXTURE_CUBE_MAP_NEGATIVE_X_ARB    +rz    -ry   rx \n"
"	+ry          TEXTURE_CUBE_MAP_POSITIVE_Y_ARB    +rx    +rz   ry \n"
"	-ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB    +rx    -rz   ry \n"
"	+rz          TEXTURE_CUBE_MAP_POSITIVE_Z_ARB    +rx    -ry   rz \n"
"	-rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB    -rx    -ry   rz \n"
"*/ \n"
" \n"
"	final vec3 posXDirection = normalize(vec3( 1, -t, -s)); \n"
"	final vec3 negXDirection = normalize(vec3(-1, -t,  s));	 \n"
"	final vec3 posYDirection = normalize(vec3( s,  1,  t)); \n"
"	final vec3 negYDirection = normalize(vec3( s, -1, -t)); \n"
"	final vec3 posZDirection = normalize(vec3( s, -t,  1)); \n"
"	final vec3 negZDirection = normalize(vec3(-s, -t, -1)); \n"
" \n"
"	posXLayer = computeConvolutionForDirection(posXDirection); \n"
"	negXLayer = computeConvolutionForDirection(negXDirection); \n"
"	posYLayer = computeConvolutionForDirection(posYDirection); \n"
"	negYLayer = computeConvolutionForDirection(negYDirection); \n"
"	posZLayer = computeConvolutionForDirection(posZDirection); \n"
"	negZLayer = computeConvolutionForDirection(negZDirection); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/env_map_renderer.frag"] = 
"#version 330 core \n"
" \n"
"#define final \n"
" \n"
"#ifndef NUMLIGHTS \n"
"#define NUMLIGHTS 1 \n"
"#endif \n"
" \n"
"struct LightParameters { \n"
"	vec3 color; \n"
"	vec3 direction; \n"
"	float innerAngle; \n"
"	float outerAngle; \n"
"}; \n"
" \n"
"uniform LightParameters lights[NUMLIGHTS]; \n"
" \n"
"in vec2 texcoord; \n"
" \n"
"layout(location = 0) out vec3 posXLayer; \n"
"layout(location = 1) out vec3 negXLayer; \n"
"layout(location = 2) out vec3 posYLayer; \n"
"layout(location = 3) out vec3 negYLayer; \n"
"layout(location = 4) out vec3 posZLayer; \n"
"layout(location = 5) out vec3 negZLayer; \n"
" \n"
"float lightFalloff(const in vec3 direction, const in vec3 referenceDirection, const in float innerAngle, const in float fallOffAngle) { \n"
"	return 1 - smoothstep(innerAngle, innerAngle+fallOffAngle, acos(dot(direction, referenceDirection))); \n"
"} \n"
" \n"
"vec3 computeRadianceForDirection(const in vec3 direction) { \n"
"	vec3 outRadiance = vec3(0.0); \n"
"	for(int i=0; i<NUMLIGHTS; ++i) { \n"
"		outRadiance += lights[i].color * lightFalloff(normalize(lights[i].direction), direction, lights[i].innerAngle, lights[i].outerAngle); \n"
"	} \n"
"	return outRadiance; \n"
"} \n"
" \n"
"void main() { \n"
"    final float s = 2.0 * texcoord.x - 1.0; \n"
"	final float t = 2.0 * texcoord.y - 1.0; \n"
"	 \n"
"/* \n"
"	major axis \n"
"	direction     target                             sc     tc    ma \n"
"	----------    -------------------------------    ---    ---   --- \n"
"	+rx          TEXTURE_CUBE_MAP_POSITIVE_X_ARB    -rz    -ry   rx \n"
"	-rx          TEXTURE_CUBE_MAP_NEGATIVE_X_ARB    +rz    -ry   rx \n"
"	+ry          TEXTURE_CUBE_MAP_POSITIVE_Y_ARB    +rx    +rz   ry \n"
"	-ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB    +rx    -rz   ry \n"
"	+rz          TEXTURE_CUBE_MAP_POSITIVE_Z_ARB    +rx    -ry   rz \n"
"	-rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB    -rx    -ry   rz \n"
"*/ \n"
" \n"
"	final vec3 posXDirection = normalize(vec3( 1, -t, -s)); \n"
"	final vec3 negXDirection = normalize(vec3(-1, -t,  s));	 \n"
"	final vec3 posYDirection = normalize(vec3( s,  1,  t)); \n"
"	final vec3 negYDirection = normalize(vec3( s, -1, -t)); \n"
"	final vec3 posZDirection = normalize(vec3( s, -t,  1)); \n"
"	final vec3 negZDirection = normalize(vec3(-s, -t, -1)); \n"
" \n"
"	posXLayer = computeRadianceForDirection(posXDirection); \n"
"	negXLayer = computeRadianceForDirection(negXDirection); \n"
"	posYLayer = computeRadianceForDirection(posYDirection); \n"
"	negYLayer = computeRadianceForDirection(negYDirection); \n"
"	posZLayer = computeRadianceForDirection(posZDirection); \n"
"	negZLayer = computeRadianceForDirection(negZDirection); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/cone_lighting.frag"] = 
"#version 330 core \n"
" \n"
"#define final \n"
" \n"
"#extension GL_ARB_texture_cube_map_array : enable \n"
" \n"
"uniform sampler2D bnAOTexture; // direction \n"
" \n"
"uniform sampler2D normalTexture; \n"
"uniform sampler2D diffuseTexture; \n"
" \n"
"uniform samplerCubeArray convolvedEnvMapArray; \n"
" \n"
"uniform float cubeMapArrayLayerCount; \n"
" \n"
"in vec2 texcoord; \n"
" \n"
"out vec4 radianceLayer; \n"
" \n"
"vec4 lerpTextureCubeArray(const in samplerCubeArray textureCUBEArray, const in vec3 direction, const in float index) { \n"
"	final vec4 texel0 = texture(textureCUBEArray, vec4(direction, int(index) + 0)); \n"
"	final vec4 texel1 = texture(textureCUBEArray, vec4(direction, min(float(int(index) + 1), cubeMapArrayLayerCount-1.0))); \n"
"	final float weight = fract(index); \n"
"	return mix(texel0, texel1, weight); \n"
"} \n"
" \n"
"float coneAngleToArrayIndex(const in float angle) { \n"
"	return max(0.0, angle * (cubeMapArrayLayerCount-1.0)); \n"
"} \n"
" \n"
"float arrayIndexFrom01(const in float value) { \n"
"	return value * (cubeMapArrayLayerCount-1.0); \n"
"} \n"
" \n"
"vec3 decodeNormal(const in vec3 normal) { \n"
"	return normal * 2.0 - 1.0; \n"
"} \n"
" \n"
"void main() { \n"
"	final vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb; \n"
"	final vec4 bnAo = texelFetch(bnAOTexture, ivec2(gl_FragCoord.xy), 0); \n"
"	final vec3 bentNormal = decodeNormal(bnAo.xyz) + normal; \n"
"	final float ao = bnAo.w; \n"
" \n"
"	radianceLayer = vec4(0.0); \n"
" \n"
"	if(dot(normal, vec3(1.0)) == 0.0) { \n"
"		return; \n"
"	} \n"
"	radianceLayer.w = 1.0; \n"
" \n"
"	final float arrayIndex = arrayIndexFrom01(clamp(length(bentNormal) * 2.0 - 1.0, 0.0, 1.0)); \n"
" \n"
"	vec3 bentNormalNormalized = normalize(bentNormal); \n"
"	final vec3 direction = bentNormalNormalized; \n"
" \n"
"	vec3 diffuseColor = texelFetch(diffuseTexture, ivec2(gl_FragCoord.xy), 0).rgb; \n"
" \n"
"	// geometric term heuristic \n"
"	radianceLayer.rgb = lerpTextureCubeArray(convolvedEnvMapArray, direction, arrayIndex).rgb * dot(normal, bentNormalNormalized); \n"
"	radianceLayer.rgb *= ao; \n"
"	radianceLayer.rgb *= diffuseColor; \n"
"	 \n"
"	//if(texcoord.x > 0.5) { \n"
"	//	if(texcoord.y > 0.5) { \n"
"	//		// ao only \n"
"	//		radianceLayer.rgb = vec3(ao); \n"
"	//	} \n"
"	//	else { \n"
"	//		// ao lighting \n"
"	//		radianceLayer.rgb = lerpTextureCubeArray(convolvedEnvMapArray, normal, 0.0).rgb; \n"
"	//		radianceLayer.rgb *= ao; \n"
"	//		radianceLayer.rgb *= diffuseColor; \n"
"	//	} \n"
"	//} \n"
"	//else { \n"
"	//	//radianceLayer.rgb = normal; \n"
"	//	if(texcoord.y > 0.5) { \n"
"	//		// bent normal lighting \n"
"	//		radianceLayer.rgb = lerpTextureCubeArray(convolvedEnvMapArray, direction, 0.0).rgb; \n"
"	//		radianceLayer.rgb *= ao; \n"
"	//		radianceLayer.rgb *= diffuseColor; \n"
"	//	} \n"
"	//	else { \n"
"	//		// bent cone lighting \n"
"	//		radianceLayer.rgb = lerpTextureCubeArray(convolvedEnvMapArray, direction, arrayIndex).rgb * dot(normal, bentNormalNormalized); \n"
"	//		radianceLayer.rgb *= ao; \n"
"	//		radianceLayer.rgb *= diffuseColor; \n"
"	//	} \n"
"	//} \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/sky.frag"] = 
"#version 330 core \n"
" \n"
"uniform samplerCube envMap; \n"
" \n"
"in vec3 viewDir; \n"
" \n"
"out vec4 outColor; \n"
" \n"
"void main() { \n"
"	vec3 viewDirection = normalize(viewDir); \n"
"	outColor.rgb = texture(envMap, viewDirection).rgb; \n"
"	//outColor.rgb = vec3(dot(viewDirection, vec3(0.0, 0.0, 1.0))); \n"
"	//outColor.rgb = viewDirection; \n"
" \n"
"	outColor.a = 1.0; \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/sky.vert"] = 
"#version 330 core   \n"
" \n"
"layout(location = 0) in vec2 position; \n"
" \n"
"uniform mat4 invViewProjection; \n"
" \n"
"out vec3 viewDir; \n"
" \n"
"void main() { \n"
"	vec4 homViewDir = invViewProjection * vec4(position, 1.0, 1.0); \n"
"	homViewDir.xyz /= homViewDir.w; \n"
"	vec4 homViewDir2 = invViewProjection * vec4(position, -1.0, 1.0); \n"
"	homViewDir2.xyz /= homViewDir2.w; \n"
"	viewDir.xyz = normalize(homViewDir.xyz - homViewDir2.xyz); \n"
" \n"
"	gl_Position = vec4(position, 0.99999, 1.0); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/gbuffer.frag"] = 
"#version 330 core \n"
" \n"
"struct MaterialParameters { \n"
"    // rgb \n"
"    //vec3 ambient; \n"
"    // diffuse provided as texture?! \n"
"    vec3 diffuse; \n"
"}; \n"
" \n"
"uniform sampler2D diffuseTexture; \n"
"uniform MaterialParameters material; \n"
"uniform float gamma; // gamma correction \n"
" \n"
"in Vert { \n"
"	vec3 position; \n"
"	vec3 normal; \n"
"    vec2 texcoord; \n"
"} vert; \n"
" \n"
"layout(location = 0) out vec4 outPosition; \n"
"layout(location = 1) out vec3 outNormal; \n"
"layout(location = 2) out vec3 outDiffuse; \n"
" \n"
" \n"
"void main() { \n"
"    outDiffuse = texture(diffuseTexture, vert.texcoord).rgb * material.diffuse; \n"
"	outDiffuse = pow(outDiffuse, vec3(gamma)); \n"
" \n"
"	outPosition = vec4(vert.position, 1.0); \n"
"	outNormal = normalize(vert.normal); \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

fileName2Source_["shaders/gbuffer.vert"] = 
"#version 330 core \n"
" \n"
"uniform mat4 MVP; \n"
"uniform mat3 normalM; \n"
" \n"
"layout(location = 0) in vec3 position; \n"
"layout(location = 1) in vec3 normal; \n"
"layout(location = 2) in vec2 texcoord; \n"
" \n"
"out Vert { \n"
"	vec3 position; \n"
"	vec3 normal; \n"
"    vec2 texcoord; \n"
"} vert; \n"
" \n"
" \n"
"void main() { \n"
"    vec4 inPos = vec4(position, 1.0); \n"
" \n"
"	vert.position = position; \n"
"    //vert.normal = normalM * normalize(normal); \n"
"    vert.normal = normalize(normal); \n"
"    vert.texcoord = texcoord; \n"
" \n"
"    gl_Position = MVP * inPos; \n"
"} \n"
"";
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
